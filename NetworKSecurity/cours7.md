# Error detection and correction

- a random bit or while groups adjectant bits may be corrupted
- Wireless connections and PSTN local loops are very prone to transmission errors
- Come times error can be tolerated (ex: real time speach)

## Error detecting codes

- error detecion code (aka check bits) -> usually added at end of frame
- code generated by sender before sending
- reciever checks check bits
- if data and check bits don't mach, the data is probably corrupted

### Modular checksum (aka sumcheck):
sum values as unsigned ints and discard overflow (keep least significant byts)
can check up to 8 consecutive bit being corrupted.

Some times the check bits are inverted.

### Cyclic Redundicy Check (CRC):

- uses a hash code
- widely used
- CRC either 16 or 32 bits long
- A propelry designed N-bit CC will detect
  - all single but
  - all double bit
  - all odd numbers of bit errors
  - all errors <= N
  - most error bursts > N bits
- CRCs all detect a variaty of other error including extra zero bytes and changes in the order of bytes

## Backward Error Correction

    - Each frame has check bits
    - Reciever
      - checks error bits and discards corrupt packets
      - sends message that reception of frames was succesfull and without error for other packets
    - Sender
      - resends unaknowledged packages
- Most common approche
- Requires duplex (two-way) connection
- Unfeasable if enough noise to cause one corrupt bit per frame

## Forward error correction (FEC)

   - each frame bits has additional check bits that permit errors to be detected *and repaired*.
   - can be more efficient than backward error correction:
     - if error rate is high
     - If the propagation delay is large compared to length of a frame
- FEC is the only option for simplex (one-way) connection
- FEC generally has larger overhead (more etra bits)

## Hamming code

- All valid codes must differ from each in at leat 3 of their bits (I.e. the Hamming distance has to be at least 3)

Data	Hamming distance
00	00000
01	00111
10	11001
11	11110

Ex:

01 11 00 10 11

00111 11110 00000 11001 11110
00101 11110 00100 11000 01010

00101 -> closest is 00111 (hamming distance 1)
01111
00100 -> closest is 00000
11000 -> closest is 11001
01010 -> is this 11001 or 00000 ?

### Limits and effeciency

- In general , set of hamming codes with min distance D:
 - repair error up to (D-1)/ 2 bits
 - Detect errors affecting up to (D-1) bits per code
- number of extra bits increasses logarithmically with the number of bits encoded
- TV broadcasting using MPEG-2 every 204 bytes frame carries 16 bytes of check bits that can repair up to 8 byte of error

### Optimising for bursty noise

- In situations where noise affects multiple adjacent bits robustness, multiplexing multiplexing multiple hamming codes durring tranmissin
-> this distributes the error over multiple hamming codes thus avoiding having a corrupt byte
random noise will not be mmade less fixable by multiplexing
constant noise at synchronised with the multiplexing rate may cause more errors.
